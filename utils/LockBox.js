"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LockBox = void 0;
const utilities_1 = require("./utilities");
const types_1 = require("../structures/types");
const fs_1 = __importDefault(require("fs"));
const node_crypto_1 = __importDefault(require("node:crypto"));
/**
 *  Fluttershy's LockBox.
 *  Author: [EllyPony]({@link EllyPonyUrl})
 *
 *  @classdesc Helper class for the secure encryption and decryption of data. Mostly, for the
 * secure storage of client secrets / other confidential potentially discriminating data.
 *
 *  @summary **on construction the class automatically creates a new stationary key, and checks for any .env files in the working directory whereupon
 * `ENCRYPTION_KEY=` is appended to the file**. If no enviornment variable files are found, a new blank .env file is created. **It is crucial that this
 * stationary key remain unchanged**. As all encrpytions will use a variation of buffers generated by the stationary key as a seed when ciphering. If the stationary key is lost
 * all data written with your old stationary key will be lost forever.
 *
 * For "permanent" to skip over initailizing the enviornment variable, and obsfucate something "permanantly" (you won't be able to read it again)
 * use {@link encrypt_forgetKey} to generate a unique one-time 16bit seed for the {@link crypto.createCipheriv()},
 *
 * */
class LockBox {
    /**
     * Creates an instance of the LockBox
     * @constructor
     * @memberof LockBox
     */
    constructor() {
        let initalize = process.env.ENCRYPTION_KEY ? false : true;
        if (initalize) {
            this._initEnv();
        }
    }
    /**
     * encrypt data
     * @param {any} [data]
     * @return {any} encrypted data
     * ---
     * 
     * note any data encrypted as json strings must be re-translated with JSON.parse
     */
    encrypt(data) {
        let timestamp = this._newTimestamp();
        const key = node_crypto_1.default.createHash('sha256').update(this.stationaryKey + timestamp).digest('hex');
        const iv = node_crypto_1.default.randomBytes(16); // Apparently this needs to be unique, every time. whoops. Had it in the constructor 
        const cipher = node_crypto_1.default.createCipheriv('aes-256-cbc', Buffer.from(key, 'hex'), iv);
        let encryptedData = cipher.update(data, 'utf8', 'base64');
        encryptedData += cipher.final('base64');
        // Return the timestamp + encrypted data
        return `${timestamp}:${iv.toString('hex')}:${encryptedData}`;
    }
    /**
     * Same as {@link encrypt}, but the key used for the encryption is immediately destroyed.
     * rendering whatever data it has encrypted permanent scrambled. (prob wont work, haven't tested)
     * @param {any} data
     * @returns {any} permanentley encrypted data
     */
    encrypt_forgetKey(data) {
        const iv = node_crypto_1.default.randomBytes(16);
        const cipher = node_crypto_1.default.createCipheriv('aes-256-cbc', node_crypto_1.default.randomBytes(32), Buffer.from(iv.toString(), 'hex'));
        let encryptedToken = cipher.update(data, 'utf-8', 'hex');
        encryptedToken += cipher.final('hex');
        return encryptedToken;
    }
    /**
     * decrypt data that has previously been encrypted with {@link encrypt}
     * @memberof LockBox
     * @param {string} data
     * @return {any}
     */
    decrypt(data) {
        try {
            const [timestamp, ivHex, encryptedText] = data.split(':');
            const key = node_crypto_1.default.createHash('sha256').update(this.stationaryKey + timestamp).digest('hex');
            const iv = Buffer.from(ivHex, 'hex');
            const decipher = node_crypto_1.default.createDecipheriv('aes-256-cbc', Buffer.from(key, 'hex'), iv);
            let decryptedData = decipher.update(encryptedText, 'base64', 'utf8');
            decryptedData += decipher.final('utf8');
            return decryptedData;
        }
        catch (error) {
            throw new types_1.Errors.fsLockBoxError('unable to decrypt data', error);
        }
    }
    _generateKey() {
        try {
            let Key = node_crypto_1.default.randomBytes(32).toString('hex');
            return Key;
        }
        catch (error) {
            throw new types_1.Errors.fsLockBoxError('unable to generate a new stationary key', error);
        }
    }
    _initEnv() {
        try {
            try {
                const Key = this._generateKey();
                const envKey = `
      ENCRYPTION_KEY=${Key}
    `;
                let envFiles = uUtilities.findFiles('', './', '.env'); //find custom env files
                if (!envFiles) {
                    uUtilities.Log('yellow, bold', 'WARN: Unable to find an enviornment (.env) file. Creating a new one in the working directory');
                    fs_1.default.writeFileSync(".env", envKey, { flag: 'a' });
                }
                else {
                    fs_1.default.writeFileSync(envFiles[0], envKey, { flag: 'a' });
                    uUtilities.Log('created new key and updated .env file');
                }
            }
            catch (error) {
                throw new types_1.Errors.fsLockBoxError('error updating the enviornment', error);
            }
        }
        catch (error) {
            throw new types_1.Errors.fsLockBoxError('', error);
        }
    }
    _newTimestamp() {
        return Date.now().toString();
    }
}
exports.LockBox = LockBox;
exports.default = LockBox;
